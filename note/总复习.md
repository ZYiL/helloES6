1.  变量 let const

|声明方式 | 能否重复声明 | 作用域 | 类型|是否支持变量提升|
| ------| ------ | ------ |------|-----|
| var| 能 | 函数级 |变量|是,undefined|
| let | 不能,不允许在相同作用域内，重复声明同一个变量| 块级 |变量|否,referrenceError:is not defined|
| const|不能| 块级|常量|否|
>   *暂时性死区*：在代码**块内**，使用let命令**声明**变量**之前**，该变量都是**不可用**的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）
2.  箭头函数
    -  方便
        -   如果只有一个参数，（）可以省略
        -   如果只有一个语句且为return,{}可以省略
    -   修正this
        -   只会从自己的作用域链的上一层继承this
        -   箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数
        -   函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。所以this对象的指向是可变的，但是在箭头函数中，它是固定的。
        -   不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误
        -   不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替
        -   不可以使用yield命令，因此箭头函数不能用作 Generator 函数
    -   不适用场合
        -   定义对象的方法，且该方法内部包括this。
        -   需要动态this的时候，也不应使用箭头函数
>   *作用域* ：一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。

3.  参数的扩展...rest
    -   收集
    -   扩展
    -   默认参数
4.  数组方法
    -   map 映射
    -   reduce  汇总
    -   filter  过滤
    -   forEach     循环
5.  字符串
    -   startWith
    -   endWith
    -   字符串模板  `${a}xxx${b}`
6.  Promise
    -   封装异步操作
    -   Promise.all([]).then()
7.  generator
    -   执行一半能暂停
    -   yield
8.  JSON
    -   JSON.stringfy()
    -   JSON.parse()
9.  面向对象
    -   class Test{}
10. 解构赋值
    -   左右结构一样
    -   右边是合法事情
    -   声明赋值一次完成
